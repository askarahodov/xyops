# Алерты

## Обзор

Алерты анализируют живые серверные данные и запускают действия при выполнении условий. В xyOps алерт определяется один раз ("definition") и может срабатывать много раз на разных серверах (каждое срабатывание — "invocation"). Алерты вычисляются каждую минуту на conductor на основе последних [ServerMonitorData](data.md#servermonitordata), собранных с каждого сервера.

Используйте алерты, чтобы выявлять состояния системы (высокий CPU, нехватка памяти, заполненный диск, всплески задач), уведомлять команды, добавлять контекст через snapshots, открывать тикеты, запускать задачи и при необходимости ограничивать или прерывать задачи на затронутых серверах.

## Концепции

- **Definition:** конфигурация, задающая условие и действия.
- **Invocation:** единичное срабатывание на сервере. Хранится в базе и отображается в Alerts.
- **Cadence:** раз в минуту на сервер, вместе с вычислением мониторов.
- **Scope:** по группам серверов. Оставьте пустым, чтобы применялось ко всем.
- **Warm-up / cool-down:** можно требовать N подряд true перед срабатыванием и N подряд false перед снятием.
- **Actions:** выполняются при срабатывании и/или снятии. Действия могут задаваться в алерте, дополняться группами и универсальными defaults.
- **Job control:** можно запретить запуск новых задач во время алерта или прервать все текущие задачи при срабатывании.

## Как вычисляются алерты

На каждый минутный блок серверных данных:

1. xyOps вычисляет каждое включенное определение алерта, чья group scope подходит серверу.
2. Выражение алерта (в формате JavaScript) выполняется над текущим snapshot [ServerMonitorData](data.md#servermonitordata).
3. Если выражение true, внутренний счетчик увеличивается. Если false и был увеличен, счетчик уменьшается к нулю.
4. Когда счетчик впервые достигает max samples, создается invocation и выполняются actions. Когда счетчик возвращается к нулю, invocation снимается и выполняются actions на снятие.

Примечания:

- Выражения компилируются заранее; синтаксические ошибки отклоняются при create/update и в Test диалоге/API.
- Сообщение алерта переоценивается каждую минуту, пока алерт активен, поэтому макросы отражают текущие значения.
- Активные invocation обновляются при поступлении данных. Устаревшие invocation автоматически истекают, если нет обновлений (например, сервер офлайн).

## Выражения алертов

Выражение алерта вычисляется в [xyOps Expression Format](xyexp.md) с контекстом [ServerMonitorData](data.md#servermonitordata). Частые точки входа:

- `cpu`: статистика CPU и железа.
- `memory`: total/available память и т.д.
- `load`: средние значения нагрузки 1/5/15 минут.
- `monitors`: значения мониторов (абсолютные).
- `deltas`: вычисленные дельты для счетчиков с прошлого измерения.
- `jobs`: количество выполняющихся задач на сервере.

Пример:

```js
monitors.load_avg >= (cpu.cores + 1)
```

Срабатывает, если 1-минутный load average >= количество ядер CPU + 1.

Пример с дельтами (для счетчиков):

```js
deltas.os_bytes_out_sec >= 33554432
```

Полезные helper функции в выражениях и макросах сообщений:

- `min(a, b)`, `max(a, b)`
- `integer(x)`, `float(x)`
- `bytes(x)` — человекочитаемые байты
- `number(x)` — локализованные числа
- `pct(x)` — проценты
- `stringify(obj)` — JSON stringify
- `find(array, key, substr)` — фильтрует массив по `item[key]` с `substr`

См. [xyOps Expression Format](xyexp.md) для подробностей.

Советы:

- Используйте `monitors.MONITORID` для абсолютных значений и `deltas.MONITORID` для per-minute rate, если монитор — счетчик.
- Защищайтесь от отсутствующих значений, например `integer(monitors.foo || 0) > 10`.

## Сообщения алертов

Сообщение алерта — это строка с макросами `{{ ... }}`, вычисляемыми в том же контексте [ServerMonitorData](data.md#servermonitordata), что и выражение. Это позволяет включать форматированные, контекстные детали в уведомления, тикеты и логи.

Пример:

```
CPU load average is too high: {{float(monitors.load_avg)}} ({{cpu.cores}} CPU cores)
```

Все helper функции из раздела выражений доступны и в макросах. Любой макрос с объектом превращается в JSON строку.

Дополнительные переменные, доступные при выполнении actions (в основном для шаблонов):

- `def`: объект определения алерта (`def.title`, `def.notes` и т.д.).
- `alert`: объект invocation (`alert.id`, `alert.message` и т.д.).
- `nice_*`: дружелюбные строки для host, IP, CPU, OS, memory, uptime, groups, notes и т.д.
- `links`: `server_url` и `alert_url` прямые ссылки.

## Создание и редактирование алертов

Нажмите "Alert Setup" в боковой панели. Для создания и редактирования нужны соответствующие привилегии. Форма включает:

- **Title**: Название алерта.
- **Status**: Включить/выключить уведомления и actions.
- **Icon**: Опциональный Material Design Icon.
- **Server Groups**: Одна или несколько групп, где действует алерт. Оставьте пустым для всех.
- **Expression**: Условие триггера, вычисляется каждую минуту. Используйте Server Data Explorer для поиска путей.
- **Message**: Текст с `{{macros}}` для динамического контекста. Вычисляется при срабатывании и каждую минуту пока активен.
- **Samples**: Количество последовательных минут true для срабатывания; также используется как cool-down для снятия.
- **Overlay**: Опциональный монитор для наложения алерт-аннотаций на графики.
- **Job Limit**: Пока алерт активен, новые задачи не запускаются на сервере.
- **Job Abort**: При срабатывании прервать все текущие задачи на сервере.
- **Alert Actions**: Опциональные actions на `alert_new` и/или `alert_cleared`.
- **Notes**: Опциональный текст, включаемый в письма и уведомления.

Testing: используйте кнопку "Test..." для проверки Expression и Message на выбранном live сервере. Диалог показывает, сработает ли сейчас, и превью сообщения.

## Actions при срабатывании и снятии

Когда алерт срабатывает (`alert_new`) и когда снимается (`alert_cleared`), xyOps выполняет actions параллельно из трех источников, с дедупликацией по type/target:

- **Alert actions**: заданные в самом алерте.
- **Group actions**: от групп, куда входит сервер.
- **Universal actions**: из `config.json` -> `alert_universal_actions` (по умолчанию `snapshot` на `alert_new`).

Поддерживаемые типы действий в алертах:

- **Email**: указанным пользователям и/или кастомным адресам.
- **Channel**: запуск канала уведомлений.
- **Run Job**: запуск задачи по событию с опциональными параметрами.
- **Create Ticket**: создание/обновление тикета, связанного с алертом.
- **Web Hook**: запуск заранее настроенного web hook с шаблонами payload.
- **Plugin**: запуск кастомного плагина с аргументами.
- **Snapshot**: создание snapshot сервера. Примечание: snapshot по умолчанию включен через universal actions.

Условия действий — `alert_new` или `alert_cleared`. Можно назначить несколько actions для каждого условия.

## Контроль задач во время алертов

- **Limit Jobs**: пока алерт активен на сервере, этот сервер исключается из планирования задач (не допускаются новые задачи). Родительские workflow задачи не подпадают под ограничение.
- **Abort Jobs**: когда алерт срабатывает, все текущие задачи на сервере немедленно прерываются.

Обе опции независимы и включаются в определении алерта.

## Примеры

В дефолтной установке есть несколько примеров алертов:

| Alert Title      | Expression                                 | Message |
|------------------|--------------------------------------------|---------|
| High CPU Load    | `monitors.load_avg >= (cpu.cores + 1)`     | CPU load average is too high: `{{float(monitors.load_avg)}}` (`{{cpu.cores}}` CPU cores) |
| Low Memory       | `memory.available < (memory.total * 0.05)` | Less than 5% of total memory is available (`{{bytes(memory.available)}}` of `{{bytes(memory.total)}}`) |
| High I/O Wait    | `monitors.io_wait >= 75`                   | Disk I/O wait is too high: `{{pct(monitors.io_wait)}}` |
| Disk Full        | `monitors.disk_usage_root >= 90`           | Root filesystem is `{{pct(monitors.disk_usage_root)}}` full. |
| High Active Jobs | `monitors.active_jobs >= 50`               | Active job count is too high: `{{number(monitors.active_jobs)}}` |

## Просмотр и поиск алертов

- **Active alerts**: отображаются в счетчике заголовка и вкладке Alerts. Каждый включает вычисленное сообщение, контекст сервера, ссылку на snapshot и связанные задачи/тикеты.
- **Timelines**: если задан `monitor_id`, аннотации алертов отображаются на графике монитора.
- **History search**: поиск по истории алертов на странице "Alerts".

## API Summary

См. [Alerts](api.md#alerts) для полного описания. Основное:

- `get_alerts`: список всех определений алертов.
- `get_alert`: получить одно определение по ID.
- `create_alert` / `update_alert` / `delete_alert`: управление определениями.
- `test_alert`: компиляция и вычисление выражения/сообщения на сервере.
- `search_alerts`: поиск исторических и активных invocations.

## Лучшие практики

- Настройте `samples`, чтобы сбалансировать шум и отзывчивость. Для всплесков требуйте несколько сэмплов.
- Предпочитайте относительные пороги (например, сравнивайте load с `cpu.cores`).
- Используйте `bytes()`/`pct()`/`number()` для читаемых сообщений.
- Накладывайте алерты на мониторы, которые уже смотрят пользователи, чтобы дать контекст.
- Используйте group-level actions для стандартных реакций (например, пейджить on-call канал) и держите per-alert actions для конкретики.
- Рассмотрите ограничение задач при условиях, снижающих надежность выполнения (например, disk full, high I/O wait).

## Привилегии

- Create: [create_alerts](privileges.md#create_alerts)
- Edit/Test: [edit_alerts](privileges.md#edit_alerts)
- Delete: [delete_alerts](privileges.md#delete_alerts)

Пользователи без этих привилегий могут читать определения и смотреть активные алерты при наличии сессии или API Key.

## See Also

- Data structures: [Alert](data.md#alert) и [AlertInvocation](data.md#alertinvocation)
- API: [Alerts](api.md#alerts)
- Monitoring data context: [ServerMonitorData](data.md#servermonitordata)
